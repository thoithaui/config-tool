from elasticsearch import Elasticsearch
from plyer import notification
import sched, time
from datetime import datetime, timedelta, timezone

# Password for the 'elastic' user generated by Elasticsearch
# ELASTIC_USERNAME = "elastic"
# ELASTIC_PASSWORD = "ductho"
# ELASTIC_HOST = "https://localhost:9200/"

def check_memory2(max):
    print(max)

def get_latest_records(max_persent):
    datastream_name = "metrics-system-memory"
    # Thay đổi địa chỉ Elasticsearch, thông tin xác thực, và phiên bản Elasticsearch theo tài khoản của bạn
    es = Elasticsearch(
        ELASTIC_HOST,
        basic_auth=(ELASTIC_USERNAME, ELASTIC_PASSWORD),
    )

    # Truy vấn Elasticsearch để lấy 1 kết quả mới nhất
    # query = {
    #     "size": 1,
    #     "sort": [{"@timestamp": {"order": "desc"}}],
    #     "query": {"match_all": {}},
    # }
    end_time = datetime.now(timezone.utc)
    start_time = datetime.now(timezone.utc) - timedelta(seconds=60)

    # Tạo truy vấn Elasticsearch với khoảng thời gian
    query = {
        "sort": [{"@timestamp": {"order": "desc"}}],
        "query": {
            "range": {
                "@timestamp": {
                    "gte": start_time,
                    "lt": end_time
                }
            }
        }
    }
    response = es.search(index=datastream_name, body=query)

    # Kiểm tra và xử lý kết quả
    if response["hits"]["hits"]:
        for hit in response["hits"]["hits"]:
            source = hit["_source"]

            timestamp = datetime.fromisoformat(source["@timestamp"])
            s = datetime.now(timezone.utc) - timestamp
            print(s.seconds)

            
            # Truy cập các trường bạn muốn từ kết quả
            percent = source["system"]["memory"]["used"]["pct"]
            # Xử lý kết quả ở đây
            # print("Field a: {}, Field b: {}".format(field_a, field_b))
            # print(percent)
            # if percent > max_persent:
            #     notification.notify(
            #         title="Memory limit: {}".format(max_persent),
            #         message="memory reached the warning limit: {}".format(percent),
            #         timeout=3,
            #     )
            #     break
    else:
        print("No records found.")
        notification.notify(title="Memory", message="Read data error", timeout=3)

    # Đóng kết nối Elasticsearch
    es.close()

def get_memory_records(max_persent, time):
    datastream_name = "metrics-system-memory"
    # Thay đổi địa chỉ Elasticsearch, thông tin xác thực, và phiên bản Elasticsearch theo tài khoản của bạn
    es = Elasticsearch(
        ELASTIC_HOST,
        basic_auth=(ELASTIC_USERNAME, ELASTIC_PASSWORD),
    )

    end_time = datetime.now(timezone.utc)
    start_time = datetime.now(timezone.utc) - timedelta(seconds=time)

    # Tạo truy vấn Elasticsearch với khoảng thời gian
    query = {
        "sort": [{"@timestamp": {"order": "desc"}}],
        "query": {
            "range": {
                "@timestamp": {
                    "gte": start_time,
                    "lt": end_time
                }
            }
        }
    }
    response = es.search(index=datastream_name, body=query)

    # Kiểm tra và xử lý kết quả
    if response["hits"]["hits"]:
        for hit in response["hits"]["hits"]:
            source = hit["_source"]

            timestamp = datetime.fromisoformat(source["@timestamp"])
            percent = source["system"]["memory"]["used"]["pct"]
            if percent > max_persent:
                notification.notify(
                    title="Memory limit: {}%".format(max_persent*100),
                    message="memory reached the warning limit: {}%".format(percent*100),
                    timeout=3,
                )
                break
    else:
        print("No records found.")
        notification.notify(title="Memory", message="Read data error", timeout=3)

    # Đóng kết nối Elasticsearch
    es.close()

def get_cpu_records(max_persent, time):
    datastream_name = "metrics-system-cpu"
    # Thay đổi địa chỉ Elasticsearch, thông tin xác thực, và phiên bản Elasticsearch theo tài khoản của bạn
    es = Elasticsearch(
        ELASTIC_HOST,
        basic_auth=(ELASTIC_USERNAME, ELASTIC_PASSWORD),
    )

    end_time = datetime.now(timezone.utc)
    start_time = datetime.now(timezone.utc) - timedelta(seconds=time)

    # Tạo truy vấn Elasticsearch với khoảng thời gian
    query = {
        "sort": [{"@timestamp": {"order": "desc"}}],
        "query": {
            "range": {
                "@timestamp": {
                    "gte": start_time,
                    "lt": end_time
                }
            }
        }
    }
    response = es.search(index=datastream_name, body=query)

    # Kiểm tra và xử lý kết quả
    if response["hits"]["hits"]:
        for hit in response["hits"]["hits"]:
            source = hit["_source"]

            timestamp = datetime.fromisoformat(source["@timestamp"])
            percent = source["system"]["cpu"]["total"]["norm"]["pct"]
            if percent > max_persent:
                notification.notify(
                    title="CPU limit: {}%".format(max_persent*100),
                    message="CPU reached the warning limit: {:.1f}%".format(percent*100),
                    timeout=3,
                )
                break
    else:
        print("No records found.")
        notification.notify(title="Memory", message="Read data error", timeout=3)

    # Đóng kết nối Elasticsearch
    es.close()

def get_max_cpu(max_persent, time, ELASTIC_HOST, ELASTIC_USERNAME, ELASTIC_PASSWORD):
    datastream_name = "metrics-system-cpu"
    # Thay đổi địa chỉ Elasticsearch, thông tin xác thực, và phiên bản Elasticsearch theo tài khoản của bạn
    es = Elasticsearch(
        ELASTIC_HOST,
        basic_auth=(ELASTIC_USERNAME, ELASTIC_PASSWORD),
    )

    # end_time = datetime.now(timezone.utc)
    # start_time = datetime.now(timezone.utc) - timedelta(seconds=time)
    # Tạo truy vấn Elasticsearch với khoảng thời gian
    query = {
        "size": 0,
        "query": {
          "range": {
            "@timestamp": {
              "gte": "now-"+str(time)+"s",
              "lte": "now"
            }
          }
        },
        "aggs": {
          "hosts": {
            "terms": {
              "field": "host.hostname",
              "size": 10
            },
            "aggs": {
              "max_pct": {
                "max": {
                  "field": "host.cpu.usage"
                }
              }
            }
          }
        }
    }
    response = es.search(index=datastream_name, body=query)

    # Kiểm tra và xử lý kết quả
    if response["aggregations"]["hosts"]["buckets"]:
        for host in response["aggregations"]["hosts"]["buckets"]:
            host_name = host["key"]
            percent = host["max_pct"]["value"]
            if percent > max_persent/100:
                notification.notify(
                   message="CPU {} reached the warning limit: {:.1f}%".format(host_name,percent*100),
                    timeout=3,
                )
    else:
        print("No records found.")
        notification.notify(title="CPU", message="Read data error", timeout=3)

    # Đóng kết nối Elasticsearch
    es.close()


def get_max_memory(max_persent, time, ELASTIC_HOST, ELASTIC_USERNAME, ELASTIC_PASSWORD):
    datastream_name = "metrics-system-memory"
    # Thay đổi địa chỉ Elasticsearch, thông tin xác thực, và phiên bản Elasticsearch theo tài khoản của bạn
    es = Elasticsearch(
        ELASTIC_HOST,
        basic_auth=(ELASTIC_USERNAME, ELASTIC_PASSWORD),
    )
    # end_time = datetime.now(timezone.utc)
    # start_time = datetime.now(timezone.utc) - timedelta(seconds=time)

    # Tạo truy vấn Elasticsearch với khoảng thời gian
    query = {
        "size": 0,
        "query": {
          "range": {
            "@timestamp": {
              "gte": "now-"+str(time)+"s",
              "lte": "now"
            }
          }
        },
        "aggs": {
          "hosts": {
            "terms": {
              "field": "host.hostname",
              "size": 10
            },
            "aggs": {
              "max_pct": {
                "max": {
                  "field": "system.memory.used.pct"
                }
              }
            }
          }
        }
    }
    response = es.search(index=datastream_name, body=query)

    # Kiểm tra và xử lý kết quả
    if response["aggregations"]["hosts"]["buckets"]:
        for host in response["aggregations"]["hosts"]["buckets"]:
            host_name = host["key"]
            percent = host["max_pct"]["value"]
            if percent > max_persent/100:
                notification.notify(
                   message="Memory {} reached the warning limit: {:.1f}%".format(host_name,percent*100),
                    timeout=3,
                )
    else:
        print("No records found.")
        notification.notify(title="Memory", message="Read data error", timeout=3)

    # Đóng kết nối Elasticsearch
    es.close()

def get_mysql_max_connected(max_con, time, ELASTIC_HOST, ELASTIC_USERNAME, ELASTIC_PASSWORD):
    datastream_name = "metrics-mysql-status"
    # Thay đổi địa chỉ Elasticsearch, thông tin xác thực, và phiên bản Elasticsearch theo tài khoản của bạn
    es = Elasticsearch(
        ELASTIC_HOST,
        basic_auth=(ELASTIC_USERNAME, ELASTIC_PASSWORD),
    )

    # end_time = datetime.now(timezone.utc)
    # start_time = datetime.now(timezone.utc) - timedelta(seconds=time)

    # Tạo truy vấn Elasticsearch với khoảng thời gian
    query = {
        "size": 0,
        "query": {
          "range": {
            "@timestamp": {
              "gte": "now-20s",
              "lte": "now"
            }
          }
        },
        "aggs": {
          "hosts": {
            "terms": {
              "field": "host.hostname",
              "size": 10
            },
            "aggs": {
              "max_pct": {
                "max": {
                  "field": "mysql.status.threads.connected"
                }
              }
            }
          }
        }
    }
    response = es.search(index=datastream_name, body=query)

    # Kiểm tra và xử lý kết quả
    if response["aggregations"]["hosts"]["buckets"]:
        for host in response["aggregations"]["hosts"]["buckets"]:
            host_name = host["key"]
            con = host["max_pct"]["value"]
            if con > max_con:
                notification.notify(
                   message="MySQL {} reached the warning limit: {:.0f} connected".format(host_name,con),
                    timeout=3,
                )
    else:
        print("No records found.")
        notification.notify(title="MySQL", message="Read data error", timeout=3)

    # Đóng kết nối Elasticsearch
    es.close()

def get_mysql_error(max_con, time, ELASTIC_HOST, ELASTIC_USERNAME, ELASTIC_PASSWORD):
    datastream_name = "logs-mysql-error"
    # Thay đổi địa chỉ Elasticsearch, thông tin xác thực, và phiên bản Elasticsearch theo tài khoản của bạn
    es = Elasticsearch(
        ELASTIC_HOST,
        basic_auth=(ELASTIC_USERNAME, ELASTIC_PASSWORD),
    )

    # end_time = datetime.now(timezone.utc)
    # start_time = datetime.now(timezone.utc) - timedelta(seconds=time)

    # Tạo truy vấn Elasticsearch với khoảng thời gian

    # Tạo truy vấn Elasticsearch với khoảng thời gian
    query = {
      "query": {
        "bool": {
          "must": [
            {
              "match": {
                "level": "ERROR"
              }
            },
            {
              "range": {
                "@timestamp": {
                  "gte": "now-20s",
                  "lte": "now"
                }
              }
            }
          ]
        }
      }
    }

    
    response = es.search(index=datastream_name, body=query)
    # Kiểm tra và xử lý kết quả
    if response["hits"]["hits"]:
        for hit in response["hits"]["hits"]:
            source = hit["_source"]

            # Truy cập các trường bạn muốn từ kết quả
            err = source["level"]
            code = source["error_code"]
            if err == "ERROR":
                notification.notify(
                    title="Mysql Error",
                    message="New error: {}".format(code),
                    timeout=3,
                )
            #     break
    else:
        print("No records found.")
        notification.notify(title="Memory", message="Read data error", timeout=3)

    # Đóng kết nối Elasticsearch
    es.close()

# get_max_cpu(30,20,"https://localhost:9200/","elastic","ductho")

# Gọi hàm để lấy 10 kết quả mới nhất
# Lặp lại truy vấn mỗi 10 giây
# def run_memory_check(scheduler):
#     # schedule the next call first
#     scheduler.enter(10, 1, run_memory_check, (scheduler,))
#     get_latest_records(0.8)
#     # then do your stuff

# my_scheduler = sched.scheduler(time.time, time.sleep)
# my_scheduler.enter(10, 1, run_memory_check, (my_scheduler,))
# my_scheduler.run()
