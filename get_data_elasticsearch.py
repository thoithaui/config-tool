from elasticsearch import Elasticsearch
from plyer import notification
import sched, time
from datetime import datetime, timedelta, timezone

# Password for the 'elastic' user generated by Elasticsearch
# ELASTIC_USERNAME = "elastic"
# ELASTIC_PASSWORD = "ductho"
# ELASTIC_HOST = "https://localhost:9200/"

def create_elastic_cons(ELASTIC_HOST, ELASTIC_USERNAME, ELASTIC_PASSWORD):
    global es
    es = Elasticsearch(
        ELASTIC_HOST,
        basic_auth=(ELASTIC_USERNAME, ELASTIC_PASSWORD),
    )
def end_elastic_cons():
    es.close()

def get_latest_records(max_persent):
    datastream_name = "metrics-system-memory"
    # Thay đổi địa chỉ Elasticsearch, thông tin xác thực, và phiên bản Elasticsearch theo tài khoản của bạn
    # es = Elasticsearch(
    #     ELASTIC_HOST,
    #     basic_auth=(ELASTIC_USERNAME, ELASTIC_PASSWORD),
    # )

    # Truy vấn Elasticsearch để lấy 1 kết quả mới nhất
    # query = {
    #     "size": 1,
    #     "sort": [{"@timestamp": {"order": "desc"}}],
    #     "query": {"match_all": {}},
    # }
    end_time = datetime.now(timezone.utc)
    start_time = datetime.now(timezone.utc) - timedelta(seconds=60)

    # Tạo truy vấn Elasticsearch với khoảng thời gian
    query = {
        "sort": [{"@timestamp": {"order": "desc"}}],
        "query": {
            "range": {
                "@timestamp": {
                    "gte": start_time,
                    "lt": end_time
                }
            }
        }
    }
    response = es.search(index=datastream_name, body=query)

    # Kiểm tra và xử lý kết quả
    if response["hits"]["hits"]:
        for hit in response["hits"]["hits"]:
            source = hit["_source"]

            timestamp = datetime.fromisoformat(source["@timestamp"])
            s = datetime.now(timezone.utc) - timestamp
            print(s.seconds)

            
            # Truy cập các trường bạn muốn từ kết quả
            percent = source["system"]["memory"]["used"]["pct"]
            # Xử lý kết quả ở đây
            # print("Field a: {}, Field b: {}".format(field_a, field_b))
            # print(percent)
            # if percent > max_persent:
            #     notification.notify(
            #         title="Memory limit: {}".format(max_persent),
            #         message="memory reached the warning limit: {}".format(percent),
            #         timeout=3,
            #     )
            #     break
    
        notification.notify(title="Memory", message="Read data error", timeout=3)

    # Đóng kết nối Elasticsearch
    # es.close()

def get_memory_records(max_persent, time):
    datastream_name = "metrics-system-memory"
    # Thay đổi địa chỉ Elasticsearch, thông tin xác thực, và phiên bản Elasticsearch theo tài khoản của bạn
    # es = Elasticsearch(
    #     ELASTIC_HOST,
    #     basic_auth=(ELASTIC_USERNAME, ELASTIC_PASSWORD),
    # )

    end_time = datetime.now(timezone.utc)
    start_time = datetime.now(timezone.utc) - timedelta(seconds=time)

    # Tạo truy vấn Elasticsearch với khoảng thời gian
    query = {
        "sort": [{"@timestamp": {"order": "desc"}}],
        "query": {
            "range": {
                "@timestamp": {
                    "gte": start_time,
                    "lt": end_time
                }
            }
        }
    }
    response = es.search(index=datastream_name, body=query)

    # Kiểm tra và xử lý kết quả
    if response["hits"]["hits"]:
        for hit in response["hits"]["hits"]:
            source = hit["_source"]

            timestamp = datetime.fromisoformat(source["@timestamp"])
            percent = source["system"]["memory"]["used"]["pct"]
            if percent > max_persent:
                notification.notify(
                    title="Memory limit: {}%".format(max_persent*100),
                    message="memory reached the warning limit: {}%".format(percent*100),
                    timeout=3,
                )
                break
    
        notification.notify(title="Memory", message="Read data error", timeout=3)

    # Đóng kết nối Elasticsearch
    # es.close()

def get_cpu_records(max_persent, time):
    datastream_name = "metrics-system-cpu"
    # Thay đổi địa chỉ Elasticsearch, thông tin xác thực, và phiên bản Elasticsearch theo tài khoản của bạn
    # es = Elasticsearch(
    #     ELASTIC_HOST,
    #     basic_auth=(ELASTIC_USERNAME, ELASTIC_PASSWORD),
    # )

    end_time = datetime.now(timezone.utc)
    start_time = datetime.now(timezone.utc) - timedelta(seconds=time)

    # Tạo truy vấn Elasticsearch với khoảng thời gian
    query = {
        "sort": [{"@timestamp": {"order": "desc"}}],
        "query": {
            "range": {
                "@timestamp": {
                    "gte": start_time,
                    "lt": end_time
                }
            }
        }
    }
    response = es.search(index=datastream_name, body=query)

    # Kiểm tra và xử lý kết quả
    if response["hits"]["hits"]:
        for hit in response["hits"]["hits"]:
            source = hit["_source"]

            timestamp = datetime.fromisoformat(source["@timestamp"])
            percent = source["system"]["cpu"]["total"]["norm"]["pct"]
            if percent > max_persent:
                notification.notify(
                    title="CPU limit: {}%".format(max_persent*100),
                    message="CPU reached the warning limit: {:.1f}%".format(percent*100),
                    timeout=3,
                )
                break
    
        notification.notify(title="Memory", message="Read data error", timeout=3)

    # Đóng kết nối Elasticsearch
    # es.close()

def get_max_cpu(max_persent, time):
    datastream_name = "metrics-system-cpu"
    # Thay đổi địa chỉ Elasticsearch, thông tin xác thực, và phiên bản Elasticsearch theo tài khoản của bạn
    # es = Elasticsearch(
    #     ELASTIC_HOST,
    #     basic_auth=(ELASTIC_USERNAME, ELASTIC_PASSWORD),
    # )

    # end_time = datetime.now(timezone.utc)
    # start_time = datetime.now(timezone.utc) - timedelta(seconds=time)
    # Tạo truy vấn Elasticsearch với khoảng thời gian
    query = {
        "size": 0,
        "query": {
          "range": {
            "@timestamp": {
              "gte": "now-"+str(time)+"s",
              "lte": "now"
            }
          }
        },
        "aggs": {
          "hosts": {
            "terms": {
              "field": "host.hostname",
              "size": 10
            },
            "aggs": {
              "max_pct": {
                "max": {
                  "field": "host.cpu.usage"
                }
              }
            }
          }
        }
    }
    response = es.search(index=datastream_name, body=query)
    alert = []
    # Kiểm tra và xử lý kết quả
    if response["aggregations"]["hosts"]["buckets"]:
        for host in response["aggregations"]["hosts"]["buckets"]:
            host_name = host["key"]
            percent = host["max_pct"]["value"]
            if percent > max_persent/100:
                # notification.notify(
                #    message="CPU {} reached the warning limit: {:.1f}%".format(host_name,percent*100),
                #     timeout=3,
                # )
              message="CPU {} reached the warning limit: {:.1f}%".format(host_name,percent*100)
              alert.append(message)
    
        # notification.notify(title="CPU", message="Read data error", timeout=3)

    # Đóng kết nối Elasticsearch
    # es.close()
    return alert


def get_max_memory(max_persent, time):
    datastream_name = "metrics-system-memory"
    # Thay đổi địa chỉ Elasticsearch, thông tin xác thực, và phiên bản Elasticsearch theo tài khoản của bạn
    # es = Elasticsearch(
    #     ELASTIC_HOST,
    #     basic_auth=(ELASTIC_USERNAME, ELASTIC_PASSWORD),
    # )
    # end_time = datetime.now(timezone.utc)
    # start_time = datetime.now(timezone.utc) - timedelta(seconds=time)

    # Tạo truy vấn Elasticsearch với khoảng thời gian
    query = {
        "size": 0,
        "query": {
          "range": {
            "@timestamp": {
              "gte": "now-"+str(time)+"s",
              "lte": "now"
            }
          }
        },
        "aggs": {
          "hosts": {
            "terms": {
              "field": "host.hostname",
              "size": 10
            },
            "aggs": {
              "max_pct": {
                "max": {
                  "field": "system.memory.used.pct"
                }
              }
            }
          }
        }
    }
    response = es.search(index=datastream_name, body=query)
    alert = []
    # Kiểm tra và xử lý kết quả
    if response["aggregations"]["hosts"]["buckets"]:
        for host in response["aggregations"]["hosts"]["buckets"]:
            host_name = host["key"]
            percent = host["max_pct"]["value"]
            if percent > max_persent/100:
                # notification.notify(
                #    message="Memory {} reached the warning limit: {:.1f}%".format(host_name,percent*100),
                #     timeout=3,
                # )
              message="Memory {} reached the warning limit: {:.1f}%".format(host_name,percent*100)
              alert.append(message)
    

    # Đóng kết nối Elasticsearch
    # es.close()
    return alert

def get_mysql_max_connected(max_con, time):
    datastream_name = "metrics-mysql-status"
    # Thay đổi địa chỉ Elasticsearch, thông tin xác thực, và phiên bản Elasticsearch theo tài khoản của bạn
    # es = Elasticsearch(
    #     ELASTIC_HOST,
    #     basic_auth=(ELASTIC_USERNAME, ELASTIC_PASSWORD),
    # )

    # end_time = datetime.now(timezone.utc)
    # start_time = datetime.now(timezone.utc) - timedelta(seconds=time)

    # Tạo truy vấn Elasticsearch với khoảng thời gian
    query = {
        "size": 0,
        "query": {
          "range": {
            "@timestamp": {
              "gte": "now-"+str(time)+"s",
              "lte": "now"
            }
          }
        },
        "aggs": {
          "hosts": {
            "terms": {
              "field": "host.hostname",
              "size": 10
            },
            "aggs": {
              "max_pct": {
                "max": {
                  "field": "mysql.status.threads.connected"
                }
              }
            }
          }
        }
    }
    response = es.search(index=datastream_name, body=query)
    alert = []
    # Kiểm tra và xử lý kết quả
    if response["aggregations"]["hosts"]["buckets"]:
        for host in response["aggregations"]["hosts"]["buckets"]:
            host_name = host["key"]
            con = host["max_pct"]["value"]
            if con > max_con:
              # notification.notify(
              #    message="MySQL {} reached the warning limit: {:.0f} connected".format(host_name,con),
              #     timeout=3,
              # )
              message="MySQL {} reached the warning limit: {:.0f} connected".format(host_name,con)
              alert.append(message)
    

    # Đóng kết nối Elasticsearch
    # es.close()
    return alert

def get_mysql_error(time):
    datastream_name = "logs-mysql-error"
    # Thay đổi địa chỉ Elasticsearch, thông tin xác thực, và phiên bản Elasticsearch theo tài khoản của bạn
    # es = Elasticsearch(
    #     ELASTIC_HOST,
    #     basic_auth=(ELASTIC_USERNAME, ELASTIC_PASSWORD),
    # )

    # end_time = datetime.now(timezone.utc)
    # start_time = datetime.now(timezone.utc) - timedelta(seconds=time)

    # Tạo truy vấn Elasticsearch với khoảng thời gian

    # Tạo truy vấn Elasticsearch với khoảng thời gian
    query = {
      "sort": [{"@timestamp": {"order": "desc"}}],
      "query": {
        "bool": {
          "must": [
            {
              "match": {
                "level": "ERROR"
              }
            },
            {
              "range": {
                "@timestamp": {
                  "gte": "now-300s",
                  "lte": "now"
                }
              }
            }
          ]
        }
      }
    }

    
    response = es.search(index=datastream_name, body=query)
    
    alert = []
    # Kiểm tra và xử lý kết quả
    if response["hits"]["hits"]:
        for hit in response["hits"]["hits"]:
            source = hit["_source"]

            # Truy cập các trường bạn muốn từ kết quả
            err = source["level"]
            code = source["error_code"]
            timestamp = datetime.fromisoformat(source["@timestamp"])
            s = datetime.now(timezone.utc) - timestamp
            if err == "ERROR" and s.seconds < (2*int(time)):
            #     notification.notify(
            #         title="Mysql Error",
            #         message="New error: {}".format(code),
            #         timeout=3,
            #     )
              message="Mysql - New error: {}".format(code)
              alert.append(message)
              break
    

    # Đóng kết nối Elasticsearch
    # es.close()
    return alert
    
def get_mongodb_cons(max_con, time):
    datastream_name = "metrics-mongodb-status"
    # Thay đổi địa chỉ Elasticsearch, thông tin xác thực, và phiên bản Elasticsearch theo tài khoản của bạn
    # es = Elasticsearch(
    #     ELASTIC_HOST,
    #     basic_auth=(ELASTIC_USERNAME, ELASTIC_PASSWORD),
    # )

    # end_time = datetime.now(timezone.utc)
    # start_time = datetime.now(timezone.utc) - timedelta(seconds=time)

    # Tạo truy vấn Elasticsearch với khoảng thời gian

    # Tạo truy vấn Elasticsearch với khoảng thời gian
    query = {
        "size": 0,
        "query": {
          "range": {
            "@timestamp": {
              "gte": "now-"+str(time)+"s",
              "lte": "now"
            }
          }
        },
        "aggs": {
          "hosts": {
            "terms": {
              "field": "service.address",
              "size": 10
            },
            "aggs": {
              "max_cons": {
                "max": {
                  "field": "mongodb.status.connections.current"
                }
              }
            }
          }
        }
    }

    
    response = es.search(index=datastream_name, body=query)
    alert = []
    # Kiểm tra và xử lý kết quả
    if response["aggregations"]["hosts"]["buckets"]:
        for host in response["aggregations"]["hosts"]["buckets"]:
            host_name = host["key"]
            con = host["max_cons"]["value"]
            if con > max_con:
              # notification.notify(
              #    message="Mongodb {} reached the warning limit: {:.0f} connected".format(host_name,con),
              #     timeout=3,
              # )
              message="Mongodb {} reached the warning limit: {:.0f} connected".format(host_name,con)
              alert.append(message)
    
        

    # Đóng kết nối Elasticsearch
    # es.close()
    return alert

def get_mongodb_queue(max_con, time):
    datastream_name = "metrics-mongodb-status"
    # Thay đổi địa chỉ Elasticsearch, thông tin xác thực, và phiên bản Elasticsearch theo tài khoản của bạn
    # es = Elasticsearch(
    #     ELASTIC_HOST,
    #     basic_auth=(ELASTIC_USERNAME, ELASTIC_PASSWORD),
    # )

    # end_time = datetime.now(timezone.utc)
    # start_time = datetime.now(timezone.utc) - timedelta(seconds=time)

    # Tạo truy vấn Elasticsearch với khoảng thời gian

    # Tạo truy vấn Elasticsearch với khoảng thời gian
    query = {
        "size": 0,
        "query": {
          "range": {
            "@timestamp": {
              "gte": "now-"+str(time)+"s",
              "lte": "now"
            }
          }
        },
        "aggs": {
          "hosts": {
            "terms": {
              "field": "service.address",
              "size": 10
            },
            "aggs": {
              "max_cons": {
                "max": {
                  "field": "mongodb.status.global_lock.current_queue.total"
                }
              }
            }
          }
        }
    }

    
    response = es.search(index=datastream_name, body=query)
    alert = []
    # Kiểm tra và xử lý kết quả
    if response["aggregations"]["hosts"]["buckets"]:
        for host in response["aggregations"]["hosts"]["buckets"]:
            host_name = host["key"]
            con = host["max_cons"]["value"]
            if con > max_con:
            #     notification.notify(
            #        message="Mongodb {} reached the warning limit: {:.0f} global lock".format(host_name,con),
            #         timeout=3,
            #     )
              message="Mongodb {} reached the warning limit: {:.0f} global lock".format(host_name,con)
              alert.append(message)
    
        

    # Đóng kết nối Elasticsearch
    # es.close()
    return alert

def get_tomcat_total_error(max_con, time):
    datastream_name = "metrics-tomcat-metric"
    # Thay đổi địa chỉ Elasticsearch, thông tin xác thực, và phiên bản Elasticsearch theo tài khoản của bạn
    # es = Elasticsearch(
    #     ELASTIC_HOST,
    #     basic_auth=(ELASTIC_USERNAME, ELASTIC_PASSWORD),
    # )

    # Tạo truy vấn Elasticsearch với khoảng thời gian
    query = {
      "sort": [{"@timestamp": {"order": "desc"}}],
      "query": {
        "bool": {
          "must": [
            {
              "match": {
                "event.dataset": "tomcat.requests"
              }
            },
            {
              "range": {
                "@timestamp": {
                  "gte": "now-30s",
                  "lte": "now"
                }
              }
            }
          ]
        }
      }
    }
    
    response = es.search(index=datastream_name, body=query)
    alert = []
    count = 0
    total = 0
    host_name=""
    # Kiểm tra và xử lý kết quả
    if response["hits"]["hits"]:
        for hit in response["hits"]["hits"]:
            source = hit["_source"]
            if(count ==0):
              total = source["tomcat"]["requests"]["total"]
              host_name = source["service"]["address"]
              host_name = host_name[:host_name.index("/jolokia")]
            if(count == 1):
              total -= source["tomcat"]["requests"]["total"]
            if(count >= 2):
              break
            count+=1
    if count == 2 and total>max_con:
      message="Tomcat {} reached the warning limit: {:.0f} requests".format(host_name,total)
      alert.append(message)
      
            
    
            
    # Kiểm tra và xử lý kết quả
    
    # Đóng kết nối Elasticsearch
    # es.close()
    return alert

def get_tomcat_new_error(max_con, time):
    datastream_name = "metrics-tomcat-metric"
    # Thay đổi địa chỉ Elasticsearch, thông tin xác thực, và phiên bản Elasticsearch theo tài khoản của bạn
    # es = Elasticsearch(
    #     ELASTIC_HOST,
    #     basic_auth=(ELASTIC_USERNAME, ELASTIC_PASSWORD),
    # )

    # end_time = datetime.now(timezone.utc)
    # start_time = datetime.now(timezone.utc) - timedelta(seconds=time)

    # Tạo truy vấn Elasticsearch với khoảng thời gian

    # Tạo truy vấn Elasticsearch với khoảng thời gian
    query = {
        "size": 1,
        "query": {
          "range": {
            "@timestamp": {
              "gte": "now-"+str(time)+"s",
              "lte": "now"
            }
          }
        },
        "aggs": {
          "hosts": {
            "terms": {
              "field": "service.address",
              "size": 10
            },
            "aggs": {
              "max_cons": {
                "max": {
                  "field": "tomcat.requests.errors.total"
                }
              }
            }
          }
        }
    }

    
    response = es.search(index=datastream_name, body=query)
    alert = []
    # Kiểm tra và xử lý kết quả
    if response["hits"]["hits"]:
        for hit in response["hits"]["hits"]:
          source = hit["_source"]

          # Truy cập các trường bạn muốn từ kết quả
          err = source["level"]
          code = source["error_code"]
          if err == "ERROR":
            #     notification.notify(
            #         title="Mysql Error",
            #         message="New error: {}".format(code),
            #         timeout=3,
            #     )
            message="Tomcat {} reached the warning limit: {:.0f} error".format(host,code)
            alert.append(message)
    
        

    # Đóng kết nối Elasticsearch
    # es.close()
    return alert

# create_elastic_cons("https://localhost:9200/","elastic","ductho")
# get_mysql_error(10)
# end_elastic_cons()

# Gọi hàm để lấy 10 kết quả mới nhất
# Lặp lại truy vấn mỗi 10 giây
# def run_memory_check(scheduler):
#     # schedule the next call first
#     scheduler.enter(10, 1, run_memory_check, (scheduler,))
#     get_latest_records(0.8)
#     # then do your stuff

# my_scheduler = sched.scheduler(time.time, time.sleep)
# my_scheduler.enter(10, 1, run_memory_check, (my_scheduler,))